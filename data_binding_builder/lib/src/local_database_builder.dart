import 'package:build/build.dart';
import 'package:dart_style/dart_style.dart';
import 'package:path/path.dart' as p;

import 'database_description.dart';
import 'string_util.dart';

// Describe the database schema
DatabaseDescription buildDatabaseDescription() {
  var dbDescription = DatabaseDescription(meta: const {
    DatabaseDescription.META_PREPEND_ID_COLUMN: true,
    DatabaseDescription.META_VERSION: 1
  });

  String _defaultFromObjectTranslator(
          DatabaseColumnSpecification dbColSpec, String object) =>
      '$object.${snakeCaseToCamelCase(dbColSpec.name)}';
  String _zonedDateTimeTranslator(
          DatabaseColumnSpecification dbColSpec, String object) =>
      '$object.${snakeCaseToCamelCase(dbColSpec.name)}?.toIso8601String(withColon: true)';
  dbDescription.addTableSpec(
      name: 'events',
      defaultFromObjectTranslator: _defaultFromObjectTranslator,
      specContent: [
        ['experiment_id', SqlLiteDatatype.INTEGER],
        ['experiment_server_id', SqlLiteDatatype.INTEGER],
        ['experiment_name', SqlLiteDatatype.TEXT],
        ['experiment_version', SqlLiteDatatype.INTEGER],
        ['schedule_time', SqlLiteDatatype.TEXT, _zonedDateTimeTranslator],
        ['response_time', SqlLiteDatatype.TEXT, _zonedDateTimeTranslator],
        ['uploaded', SqlLiteDatatype.INTEGER],
        ['group_name', SqlLiteDatatype.TEXT],
        ['action_trigger_id', SqlLiteDatatype.INTEGER],
        ['action_trigger_spec_id', SqlLiteDatatype.INTEGER],
        ['action_id', SqlLiteDatatype.INTEGER],
      ]);
  dbDescription.addTableSpec(name: 'outputs', fromObjectLevel: 2, specContent: [
    [
      'event_id',
      SqlLiteDatatype.INTEGER,
      (dbColSpec, event, response) => '$event.id'
    ],
    [
      'text',
      SqlLiteDatatype.TEXT,
      (dbColSpec, event, response) => '$response.key'
    ],
    [
      'answer',
      SqlLiteDatatype.TEXT,
      (dbColSpec, event, response) => '$response.value'
    ]
  ]);
  return dbDescription;
}

/// How-tos
///
/// How to create a table?
String buildSqlCreateTable(
    DatabaseDescription dbDescription, String tableName) {
  var dbColumnSpecs = dbDescription.getDatabaseColumnSpecifications(tableName);
  var prependIdColumn =
      dbDescription.meta[DatabaseDescription.META_PREPEND_ID_COLUMN] ?? false;
  return '''
CREATE TABLE $tableName (
${prependIdColumn ? "_id INTEGER PRIMARY KEY AUTOINCREMENT,\n" : ""}'''
      '''
${dbColumnSpecs.map((dbColumn) => "${dbColumn.name} ${dbColumn.typeAsString}").join(', \n')}
  );
  ''';
}

/// How to get all column fields (of a table) from an object, in a default way?
/// The returned string is the representation of a map that can be used by Database.insert()
String buildDartFieldsMap(
    DatabaseDescription dbDescription, String tableName, String objectName) {
  var dbColumnSpecs = dbDescription.getDatabaseColumnSpecifications(tableName);
  var prependIdColumn =
      dbDescription.meta[DatabaseDescription.META_PREPEND_ID_COLUMN] ?? false;
  if (prependIdColumn == false) {
    throw UnimplementedError();
  }
  // We don't include the column '_id' in the returned map representation because it will be automatically generated by sqlite.
  return '''
{
  ${dbColumnSpecs.map((dbColumn) => "'${dbColumn.name}': ${dbColumn.fromObject(objectName)},").join('\n')}
}
  ''';
}

/// How to build column fields map for a second level object?
/// For example, to store object2 = object1.a_list[i]
String buildDartFieldsMap2(DatabaseDescription dbDescription, String tableName,
    String object1, String object2) {
  var dbColumnSpecs = dbDescription.getDatabaseColumnSpecifications(tableName);
  var prependIdColumn =
      dbDescription.meta[DatabaseDescription.META_PREPEND_ID_COLUMN] ?? false;
  if (prependIdColumn == false) {
    throw UnimplementedError();
  }

  return '''
  {
    ${dbColumnSpecs.map((dbColumn) => "'${dbColumn.name}': ${dbColumn.fromObject(object1, object2)},").join('\n')}
  }
  ''';
}

/// Dart code builder
class LocalDatabaseBuilder implements Builder {
  static const partOfFilename = 'local_database.dart';
  static const outputFilename = 'local_database.inc.dart';

  static AssetId _output(BuildStep buildStep) {
    return AssetId(
      buildStep.inputId.package,
      p.join('lib', 'storage', outputFilename),
    );
  }

  @override
  Map<String, List<String>> get buildExtensions {
    return const {
      r'$lib$': const ['storage/$outputFilename'],
    };
  }

  @override
  Future<void> build(BuildStep buildStep) async {
    var dbDescription = buildDatabaseDescription();
    var formatter = DartFormatter();
    final content = formatter.format('''
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by package:data_binding_builder|database_inc
// Code template can be found at package:data_binding_builder/src/local_database_builder.dart

part of '$partOfFilename';

var _dbVersion = ${dbDescription.meta[DatabaseDescription.META_VERSION]};

Future<void> _onCreate(Database db, int version) async {
${dbDescription.tableNames.map((tableName) => 'await db.execute(\'\'\'${buildSqlCreateTable(dbDescription, tableName)}\'\'\');').join('\n')}
}

Future<void> _insertEvent(Database db, Event event) async {
  try {
    db.transaction((txn) async {
      event.id = await txn.insert(
      'events',
      ${buildDartFieldsMap(dbDescription, 'events', 'event')},
      conflictAlgorithm: ConflictAlgorithm.replace,
      );
      var batch = txn.batch();
      for (var entry in event.responses.entries) {
        batch.insert('outputs', 
        ${buildDartFieldsMap2(dbDescription, 'outputs', 'event', 'entry')},
        conflictAlgorithm: ConflictAlgorithm.replace,
        );
      }
      await batch.commit(noResult: true);
    });
  } catch (e) {
    event.id = null;
    rethrow;
  }
}

    ''');

    final output = _output(buildStep);
    await buildStep.writeAsString(output, content);
  }
}
